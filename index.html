<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Dashboard de Proyectos</title>
  <link rel="stylesheet" href="styles.css"/>
  <link rel="manifest" href="manifest.json"/>
  <meta name="theme-color" content="#111827" />

  <!-- Mini estilos solo para la grilla de gráficos -->
  <style>
    .charts { display:grid; gap:16px; grid-template-columns: repeat(3, 1fr); }
    @media (max-width:1024px){ .charts { grid-template-columns: repeat(2, 1fr); } }
    @media (max-width:700px){ .charts { grid-template-columns: 1fr; } }
    .chart { display:flex; flex-direction:column; gap:8px; }
    .chart h4 { margin:0; font-size:14px; opacity:.8; }
    .chart canvas { max-height:220px; }
    .kpi #kpi-total, .kpi #kpi-done, .kpi #kpi-late, .kpi #kpi-soon { font-size:22px; font-weight:700; margin-top:6px }
  </style>

  <!-- Chart.js para las tortas -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <div class="wrap">
    <h1 id="title">Dashboard de Proyectos</h1>

    <!-- KPIs -->
    <div class="kpis">
      <div class="kpi"><div class="badge">Total</div><div id="kpi-total">–</div></div>
      <div class="kpi"><div class="badge">Finalizadas</div><div id="kpi-done">–</div></div>
      <div class="kpi"><div class="badge">Atrasadas</div><div id="kpi-late">–</div></div>
      <div class="kpi"><div class="badge">≤ 7 días</div><div id="kpi-soon">–</div></div>
    </div>

    <!-- Filtros -->
    <div class="card">
      <h3>Filtros</h3>
      <div class="filters">
        <input id="q" placeholder="Buscar texto… (cliente / proyecto / tareas)"/>
        <select id="f-cliente"><option value="">Cliente (todos)</option></select>
        <select id="f-proyecto"><option value="">Proyecto (todos)</option></select>
        <select id="f-owner"><option value="">Owner (todos)</option></select>
      </div>
    </div>

    <!-- Gráficos (debajo de filtros) -->
    <div class="card">
      <h3>Gráficos</h3>
      <div class="charts">
        <div class="chart">
          <h4>Por Estatus</h4>
          <canvas id="chStatus"></canvas>
        </div>
        <div class="chart">
          <h4>Por Owner</h4>
          <canvas id="chOwner"></canvas>
        </div>
        <div class="chart">
          <h4>Por Tipo</h4>
          <canvas id="chTipo"></canvas>
        </div>
      </div>
    </div>

    <!-- Tabla principal -->
    <div class="card">
      <div class="view-tabs">
        <button class="tab active" data-view="todo">Detalle (todas)</button>
        <button class="tab" data-view="finalizadas">Actividades finalizadas</button>
        <button class="tab" data-view="urgentes">Atrasadas y/o próximas</button>
        <button class="tab" data-view="programadas">Programadas plazo mayor</button>
      </div>

      <div class="table">
        <table id="tbl">
          <thead>
            <tr>
              <th data-sort="cliente">Cliente</th>
              <th data-sort="proyecto">Proyecto</th>
              <th data-sort="tareas">Tareas</th>
              <th data-sort="tipo">Tipo</th>
              <th data-sort="estatus">Estatus</th>
              <th data-sort="owner">Owner</th>
              <th data-sort="deadline">Deadline</th>
            </tr>
          </thead>
          <tbody id="tbody"></tbody>
          <tfoot><tr><td colspan="7" id="count">0 filas</td></tr></tfoot>
        </table>
      </div>
    </div>

    <footer>© PMO – Cristóbal Alfaro</footer>
  </div>

<script>
async function loadData() {
  let cb = Date.now();
  try {
    const r = await fetch('cache-bust.txt', { cache: 'no-store' });
    if (r.ok) cb = (await r.text()).trim();
  } catch (e) {}
  const data = await fetch('data.json?cb=' + encodeURIComponent(cb), { cache: 'no-store' })
                  .then(r => r.json());
  initDashboard(data);
}
loadData();
</script>

  // === Referencias en DOM ===
  const q = document.getElementById("q");
  const fCli = document.getElementById("f-cliente");
  const fProy = document.getElementById("f-proyecto");
  const fOwn = document.getElementById("f-owner");
  const tbody = document.getElementById("tbody");
  const count = document.getElementById("count");
  const tabs = [...document.querySelectorAll(".tab")];

  // Charts
  let chStatus = null, chOwner = null, chTipo = null;

  // Estado
  let curView = "todo";
  let curSort = { key: "deadline", dir: 1 };

  // === Utils ===
  const norm = s => (s??"").toString().trim().toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g,"");
  const isDone = r => ["finalizado","finalizada","cerrado","completado","completada"].includes(norm(r.estatus));

  // === Filtros dinámicos ===
  const uniq = arr => [...new Set(arr.filter(Boolean))].sort((a,b)=>a.localeCompare(b,'es'));
  function fillSelect(sel, list, label){
    sel.innerHTML = `<option value="">${label} (todos)</option>` + uniq(list).map(v=>`<option value="${v}">${v}</option>`).join("");
  }
  fillSelect(fCli, rows.map(r=>r.cliente), "Cliente");
  fillSelect(fProy, rows.map(r=>r.proyecto), "Proyecto");
  fillSelect(fOwn, rows.map(r=>r.owner), "Owner");

  // === KPIs ===
  function updateKPIs(data){
    const today = new Date(); today.setHours(0,0,0,0);
    const soonDays = 7*86400000;
    const done = data.filter(isDone).length;
    const late = data.filter(r=>!isDone(r) && r.deadline && new Date(r.deadline) < today).length;
    const soon = data.filter(r=>{
      if (isDone(r) || !r.deadline) return false;
      const diff = new Date(r.deadline) - today;
      return diff <= soonDays && diff >= 0;
    }).length;
    document.getElementById("kpi-total").textContent = data.length;
    document.getElementById("kpi-done").textContent  = done;
    document.getElementById("kpi-late").textContent  = late;
    document.getElementById("kpi-soon").textContent  = soon;
  }

  // === Filtrado por vista / controles ===
  function filtered(){
    const query = norm(q.value);
    const c = fCli.value, p=fProy.value, o=fOwn.value;
    const today = new Date(); today.setHours(0,0,0,0);
    const weekAhead = 14*86400000;

    return rows.filter(r=>{
      if (c && r.cliente !== c) return false;
      if (p && r.proyecto !== p) return false;
      if (o && r.owner    !== o) return false;

      if (query){
        const hay = [r.cliente,r.proyecto,r.tareas,r.estatus,r.owner].some(x=>norm(x).includes(query));
        if (!hay) return false;
      }

      const dl = r.deadline ? new Date(r.deadline) : null;
      const done = isDone(r);

      if (curView==="finalizadas") return done;

      if (curView==="urgentes"){
        if (done || !dl) return false;
        const diff = dl - today;
        return diff < 0 || diff <= weekAhead;
      }

      if (curView==="programadas"){
        if (done) return false;
        if (!dl) return true;
        const diff = dl - today;
        return diff > weekAhead;
      }

      return true;
    });
  }

  // === Gráficos ===
  function renderCharts(data){
    // Status buckets (con colores definidos)
    const STATUS_COLORS = {
      "Finalizado": "#1f77b4",         // azul
      "Iniciado en Plazo": "#2ca02c",  // verde
      "No iniciado": "#ffbf00",        // amarillo
      "On Hold": "#ff7f0e",            // naranjo
      "Atrasado": "#d62728",           // rojo
      "Otros": "#9e9e9e"
    };
    const today = new Date(); today.setHours(0,0,0,0);

    const bucketsStatus = { "Finalizado":0, "Iniciado en Plazo":0, "No iniciado":0, "On Hold":0, "Atrasado":0, "Otros":0 };
    data.forEach(r=>{
      const e = (r.estatus||"").trim();
      const t = norm(e);
      let cat = "Otros";
      if (["finalizado","finalizada","cerrado","completado","completada"].includes(t)) cat = "Finalizado";
      else if (t.includes("hold")) cat = "On Hold";
      else if (t==="iniciado" || t.includes("en plazo") || t.includes("plazo")) cat = "Iniciado en Plazo";
      else if (t.includes("no iniciado") || t.includes("pendiente")) cat = "No iniciado";
      else if (t.includes("atrasado")) cat = "Atrasado";
      // Atrasado por fecha pasada (y no finalizado)
      if (cat!=="Finalizado" && r.deadline && new Date(r.deadline) < today) cat = "Atrasado";
      bucketsStatus[cat] = (bucketsStatus[cat]||0)+1;
    });
    const order = ["Finalizado","Iniciado en Plazo","No iniciado","On Hold","Atrasado","Otros"];
    const stLabels = order.filter(k=>bucketsStatus[k]>0);
    const stCounts = stLabels.map(k=>bucketsStatus[k]);
    const stColors = stLabels.map(k=>STATUS_COLORS[k] || "#999");

    if (chStatus) chStatus.destroy();
    chStatus = new Chart(document.getElementById("chStatus"), {
      type: "pie",
      data: { labels: stLabels, datasets: [{ data: stCounts, backgroundColor: stColors }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } } }
    });

    // Owner buckets
    const byOwner = {};
    data.forEach(r=>{
      const k = r.owner || "Sin owner";
      byOwner[k] = (byOwner[k]||0)+1;
    });
    const owLabels = Object.keys(byOwner);
    const owCounts = owLabels.map(k=>byOwner[k]);
    if (chOwner) chOwner.destroy();
    chOwner = new Chart(document.getElementById("chOwner"), {
      type: "pie",
      data: { labels: owLabels, datasets: [{ data: owCounts }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } } }
    });

    // Tipo buckets
    const byTipo = {};
    data.forEach(r=>{
      const k = r.tipo || "Sin tipo";
      byTipo[k] = (byTipo[k]||0)+1;
    });
    const tpLabels = Object.keys(byTipo);
    const tpCounts = tpLabels.map(k=>byTipo[k]);
    if (chTipo) chTipo.destroy();
    chTipo = new Chart(document.getElementById("chTipo"), {
      type: "pie",
      data: { labels: tpLabels, datasets: [{ data: tpCounts }] },
      options: { responsive:true, plugins:{ legend:{ position:"bottom" } } }
    });
  }

  // === Render de tabla ===
  function render(){
    const data = filtered().sort((a,b)=>{
      const ka = a[curSort.key] ?? "";
      const kb = b[curSort.key] ?? "";
      if (curSort.key==="deadline"){
        const da = ka? new Date(ka).getTime(): 0;
        const db = kb? new Date(kb).getTime(): 0;
        return (da-db)*curSort.dir;
      }
      return ka.toString().localeCompare(kb.toString(),'es')*curSort.dir;
    });

    // filas
    const today = new Date(); today.setHours(0,0,0,0);
    tbody.innerHTML = data.map(r=>{
      let color = "#111";
      const done = isDone(r);
      const dl   = r.deadline ? new Date(r.deadline) : null;
      if (done) color = "#16a34a";
      else if (dl && dl<today) color = "#dc2626";
      const fmt = dl ? dl.toLocaleDateString("es-CL") : "";
      return `<tr style="color:${color}">
        <td>${r.cliente||""}</td>
        <td>${r.proyecto||""}</td>
        <td>${r.tareas||""}</td>
        <td>${r.tipo||""}</td>
        <td>${r.estatus||""}</td>
        <td>${r.owner||""}</td>
        <td>${fmt}</td>
      </tr>`;
    }).join("");

    count.textContent = data.length + " filas";
    updateKPIs(rows);
    renderCharts(data); // << gráficos se basan en lo filtrado actualmente
  }

  // Eventos de filtros y tabs
  q.addEventListener("input", render);
  fCli.addEventListener("change", render);
  fProy.addEventListener("change", render);
  fOwn.addEventListener("change", render);

  document.querySelectorAll("th[data-sort]").forEach(th=>{
    th.style.cursor="pointer";
    th.addEventListener("click", ()=>{
      const k = th.dataset.sort;
      if (curSort.key===k) curSort.dir*=-1;
      else {curSort.key=k; curSort.dir=1;}
      render();
    });
  });

  tabs.forEach(btn=>btn.addEventListener("click", ()=>{
    tabs.forEach(b=>b.classList.remove("active"));
    btn.classList.add("active");
    curView = btn.dataset.view;
    render();
  }));

  // Primer render
  render();
})();
</script>
      
<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', async () => {
    try {
      // Ajusta la ruta si sirves desde un subpath, ej: '/dashboard-proyectos/service-worker.js'
      const reg = await navigator.serviceWorker.register('/service-worker.js');
      // Si hay una actualización lista, actívala de inmediato:
      if (reg.waiting) reg.waiting.postMessage('SKIP_WAITING');

      // Cuando el SW nuevo tome control, recarga para usar la versión nueva
      navigator.serviceWorker.addEventListener('controllerchange', () => {
        window.location.reload();
      });
    } catch (e) {
      console.error('SW register failed', e);
    }
  });
}
</script>

</body>
</html>
